# 참조에 의한 객체 복사
> 객체와 원시 타입의 근본적인 차이 중 하나는 객체는 ‘참조에 의해(by reference)’ 저장되고 복사된다는 것.
> 원시값(문자열, 숫자, 불린 값)은 ‘값 그대로’ 저장·할당되고 복사.
    ~~~
        let message = "Hello!";
        let phrase = message;
    ~~~
- 예시를 실행하면 두 개의 독립된 변수에 각각 문자열 "Hello!"가 저장됨.
- 그런데 객체의 동작방식은 이와 다르다.
- 변수엔 객체가 그대로 저장되는 것이 아니라, 객체가 저장되어있는 '메모리 주소’인 객체에 대한 '참조 값’이 저장됨.
    ~~~
        let user = {
            name: "John"
        };
    ~~~
- 객체는 메모리 내 어딘가에 저장되고, 변수 user엔 객체를 '참조’할 수 있는 값이 저장.
- 따라서 객체가 할당된 변수를 복사할 땐 객체의 참조 값이 복사되고 객체는 복사되지 않는다.
    ~~~
        let user = { name: "John" };

        let admin = user; // 참조값을 복사함
    ~~~
- 변수는 두 개이지만 각 변수엔 동일 객체에 대한 참조 값이 저장.
- 따라서 객체에 접근하거나 객체를 조작할 땐 여러 변수를 사용할 수 있다.
    ~~~
        let user = { name: 'John' };

        let admin = user;

        admin.name = 'Pete'; // 'admin' 참조 값에 의해 변경됨

        alert(user.name); // 'Pete'가 출력됨. 'user' 참조 값을 이용해 변경사항을 확인함
    ~~~
- 객체를 서랍장에 비유하면 변수는 서랍장을 열 수 있는 열쇠. 서랍장은 하나, 서랍장을 열 수 있는 열쇠는 두 개인데, 그중 하나(admin)를 사용해 서랍장을 열어 정돈한 후, 또 다른 열쇠로 서랍장을 열면 정돈된 내용을 볼 수 있다.
<br/>

## 참조에 의한 비교
- 객체 비교 시 동등 연산자 ==와 일치 연산자 ===는 동일하게 동작.
- 비교 시 피연산자인 두 객체가 동일한 객체인 경우에 참을 반환.
- 두 변수가 같은 객체를 참조하는 예시, 일치·동등 비교 모두에서 참이 반환.
    ~~~
        let a = {};
        let b = a; // 참조에 의한 복사

        alert( a == b ); // true, 두 변수는 같은 객체를 참조합니다.
        alert( a === b ); // true
    ~~~
- 다른 예시를 살펴보면, 두 객체 모두 비어있다는 점에서 같아 보이지만, 독립된 객체이기 때문에 일치·동등 비교하면 거짓이 반환.
    ~~~
        let a = {};
        let b = {}; // 독립된 두 객체

        alert( a == b ); // false
    ~~~
- obj1 > obj2 같은 대소 비교나 obj == 5 같은 원시값과의 비교에선 객체가 원시형으로 변환.
<br/>

## 객체 복사, 병합과 Object.assign
- 객체가 할당된 변수를 복사하면 동일한 객체에 대한 참조 값이 하나 더 만들어진다는 걸 배웠다.
- 그런데 객체를 복제하고 싶다면 어떻게 해야 할까? 기존에 있던 객체와 똑같으면서 독립적인 객체를 만들고 싶다면?
- 방법은 있는데 자바스크립트는 객체 복제 내장 메서드를 지원하지 않기 때문에 어렵다. 사실 객체를 복제해야 할 일은 거의 없음. 참조에 의한 복사로 해결 가능한 일이 대다수.
- 정말 복제가 필요한 상황이라면 새로운 객체를 만든 다음 기존 객체의 프로퍼티들을 순회해 원시 수준까지 프로퍼티를 복사하면 된다.